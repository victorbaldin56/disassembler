#include "disasm.h"
#include "asm.h"
#include "read_bin.h"
#include "VM.h"
#include <assert.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>

static const size_t MAXSTR = 1000; ///< max string lenght

static int cmd_disasm(const double *code, ssize_t ip, FILE *outp_fp);

disasm_error DisAssemble(char *inp_filename, char *outp_filename) {
    assert(inp_filename);
    assert(outp_filename);

    Code code_array = {};

    if (!read_bin(inp_filename, &code_array)) {
        fprintf(stderr, "bytecode loading failure\n");
        return DISASM_BAD_ALLOC;
    }

    FILE *outp_fp = fopen(outp_filename, "w");

    if (!outp_fp) {
        perror("disasm");
        return DISASM_CREAT_FAILURE;
    }

    fprintf(outp_fp, "; Disassembled text of %s\n", inp_filename);
    fprintf(outp_fp, "; Generated by disasm (c) Victor Baldin, 2023\n\n");

    for (ssize_t ip = 0; ip < code_array.size; ip++) {
        int nargs = cmd_disasm(code_array.code, ip, outp_fp);

        if (nargs == -1) {
            fprintf(stderr, "unknown command\n");
            return DISASM_FAILURE;
        }

        ip += nargs;

    }

    fclose(outp_fp);
    free(code_array.code);

    return DISASM_SUCCEED;
}

static int cmd_disasm(const double *code, ssize_t ip, FILE *outp_fp) {
    assert(code);
    assert(outp_fp);
    assert(ip >= 0);

    char opcode = *(char *)(code + ip);

    for (size_t cp = 0; cp < sizeof(CMD_LIST) / sizeof(Command); cp++) {

        if ((opcode & CMD) == CMD_LIST[cp].opcode) {
            fprintf(outp_fp, "%s ", CMD_LIST[cp].name);

            if (opcode & REG) {
                char reg_num = *(char *)(code + ip + 1);

                switch (reg_num) {
                    case 1:
                        fprintf(outp_fp, "rax\n");
                        return 1;

                    case 2:
                        fprintf(outp_fp, "rbx\n");
                        return 1;

                    case 3:
                        fprintf(outp_fp, "rcx\n");
                        return 1;

                    case 4:
                        fprintf(outp_fp, "rdx\n");
                        return 1;

                    default:
                        return -1;

                }

            }

            else if (opcode & IMM) {
                fprintf(outp_fp, "%lf\n", code[ip + 1]);
                return 1;
            }

            else {
                fputc('\n', outp_fp);
                return 0;
            }
        }

    }

    return -1;

}
